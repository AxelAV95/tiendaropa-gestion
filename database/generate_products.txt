# pip install pyodbc faker

import pyodbc
from faker import Faker
import random
import time

# --- CONFIGURACIÓN DE LA BASE DE DATOS ---
# Modifica estos valores con los de tu conexión a SQL Server
SERVER = '.\\SQLEXPRESS'  # o el nombre de tu servidor: 'localhost', 'server.database.windows.net', etc.
DATABASE = 'tiendadb'
USERNAME = 'tu_usuario'      # Opcional si usas Autenticación de Windows
PASSWORD = 'tu_contraseña' # Opcional si usas Autenticación de Windows
# Para Autenticación de Windows, la connection string cambia. Ver abajo.

# --- CONFIGURACIÓN DEL SCRIPT ---
NUM_PRODUCTS = 100000
BATCH_SIZE = 1000  # Insertar productos en lotes de 1000 para mejor rendimiento

# Inicializar Faker para generar datos aleatorios en español
fake = Faker('es_ES')

def get_db_connection():
    """Establece y devuelve una conexión a la base de datos."""
    try:
        # Cadena de conexión para Autenticación de SQL Server
        conn_str = (
            f'DRIVER={{ODBC Driver 17 for SQL Server}};'
            f'SERVER={SERVER};'
            f'DATABASE={DATABASE};'
            f'UID={USERNAME};'
            f'PWD={PASSWORD};'
        )
        
        # --- DESCOMENTA LA SIGUIENTE LÍNEA SI USAS AUTENTICACIÓN DE WINDOWS ---
        # conn_str = (
        #     f'DRIVER={{ODBC Driver 17 for SQL Server}};'
        #     f'SERVER={SERVER};'
        #     f'DATABASE={DATABASE};'
        #     f'Trusted_Connection=yes;'
        # )
        
        conn = pyodbc.connect(conn_str)
        print("✅ Conexión a la base de datos establecida con éxito.")
        return conn
    except pyodbc.Error as ex:
        sqlstate = ex.args[0]
        print(f"❌ Error al conectar a la base de datos: {sqlstate}")
        return None

def fetch_prerequisite_ids(cursor):
    """Obtiene los IDs de las tablas de categorías y marcas."""
    print("Obteniendo IDs de categorías y marcas existentes...")
    cursor.execute("SELECT Id FROM Categories")
    category_ids = [row.Id for row in cursor.fetchall()]
    
    cursor.execute("SELECT Id FROM Brands")
    brand_ids = [row.Id for row in cursor.fetchall()]
    
    if not category_ids or not brand_ids:
        raise ValueError("Las tablas Categories o Brands están vacías. Por favor, ejecuta el script de seed primero.")
        
    print(f"Se encontraron {len(category_ids)} categorías y {len(brand_ids)} marcas.")
    return category_ids, brand_ids

def generate_products(category_ids, brand_ids):
    """Genera una lista de productos con datos falsos."""
    product_types = ['Camiseta', 'Pantalón', 'Chaqueta', 'Sudadera', 'Gorra', 'Zapatos', 'Bufanda']
    
    products_to_insert = []
    for i in range(NUM_PRODUCTS):
        product_type = random.choice(product_types)
        brand_name = fake.company().split()[0]
        
        name = f"{product_type} {brand_name} {fake.color_name().capitalize()}"
        code = f"{product_type[:3].upper()}-{fake.unique.pystr(6).upper()}"
        description = fake.text(max_nb_chars=200)
        category_id = random.choice(category_ids)
        brand_id = random.choice(brand_ids)
        base_price = round(random.uniform(5000.0, 75000.0), 2)
        min_stock = random.randint(5, 50)
        status = random.choice(['Active', 'Inactive', 'Discontinued'])
        image_url = fake.image_url()
        
        products_to_insert.append((
            code, name, description, category_id, brand_id, base_price,
            min_stock, status, image_url
        ))
        
        # Imprimir progreso
        if (i + 1) % 10000 == 0:
            print(f"  Generados {i + 1}/{NUM_PRODUCTS} productos...")
            
    return products_to_insert

def main():
    """Función principal del script."""
    start_time = time.time()
    
    conn = get_db_connection()
    if not conn:
        return

    try:
        with conn.cursor() as cursor:
            # 1. Obtener IDs necesarios
            category_ids, brand_ids = fetch_prerequisite_ids(cursor)
            
            # 2. Generar todos los datos de productos
            print(f"Generando {NUM_PRODUCTS} registros de productos. Esto puede tardar un momento...")
            products_to_insert = generate_products(category_ids, brand_ids)
            print("✅ Generación de datos completada.")
            
            # 3. Insertar los datos en lotes
            sql_insert = """
                INSERT INTO Products (
                    Code, Name, Description, CategoryId, BrandId, BasePrice,
                    MinStock, Status, ImageUrl
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            print(f"Iniciando inserción de {NUM_PRODUCTS} productos en lotes de {BATCH_SIZE}...")
            
            total_inserted = 0
            for i in range(0, len(products_to_insert), BATCH_SIZE):
                batch = products_to_insert[i:i + BATCH_SIZE]
                cursor.executemany(sql_insert, batch)
                conn.commit()
                total_inserted += len(batch)
                print(f"  Lote insertado. Total de registros: {total_inserted}/{NUM_PRODUCTS}")

            print("✅ Inserción masiva completada.")

    except (pyodbc.Error, ValueError) as e:
        print(f"❌ Ocurrió un error: {e}")
        print("Realizando rollback de la transacción...")
        conn.rollback()
    finally:
        if conn:
            conn.close()
            print("Conexión a la base de datos cerrada.")
            
    end_time = time.time()
    print(f"Script finalizado en {end_time - start_time:.2f} segundos.")

if __name__ == '__main__':
    main()